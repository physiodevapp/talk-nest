<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="/css/styles.css">
  <script src="https://cdn.tailwindcss.com"></script>
  <title>Physiodevapp Chat</title>
  <script defer>
    document.addEventListener('DOMContentLoaded', () => {
      const menuButton = document.getElementById('menuButton');
      const menu = document.getElementById('menu');

      if (!menuButton || !menu) {
        console.error('menuButton or menu not found in the DOM');
        return;
      }

      menuButton.addEventListener('click', () => {
        const isHidden = menu.classList.contains('hidden');
        if (isHidden) {
          menu.classList.remove('hidden');
          menu.classList.remove('scale-95');
          menu.classList.add('scale-100');
        } else {
          menu.classList.add('hidden');
          menu.classList.remove('scale-100');
          menu.classList.add('scale-95');
        }
      });

      document.addEventListener('click', (event) => {
        if (!menu.contains(event.target) && !menuButton.contains(event.target)) {
          menu.classList.add('hidden');
          menu.classList.remove('scale-100');
          menu.classList.add('scale-95');
        }
      });
    });
  </script>
  <script>
    const currentUser = JSON.parse('<%- JSON.stringify(currentUser) %>');
  </script>
  <script type="module">
    import { io } from "https://cdn.socket.io/4.8.1/socket.io.esm.min.js";
    import { ulid } from "https://unpkg.com/ulid@2.3.0/dist/index.js";

    let formSubmitHandler;

    const form = document.getElementById("chat-form");
    const input = document.getElementById("input");
    const messages = document.getElementById("messages");
    let lastSenderId = null;

    const openDB = () => {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open("ChatDB", 1);

        request.onupgradeneeded = (event) => {
          const db = event.target.result;
          const objectStore = db.createObjectStore("messages", { keyPath: "id" });
          objectStore.createIndex("status", "status", { unique: false });
        };

        request.onsuccess = (event) => resolve(event.target.result);
        request.onerror = (event) => reject(event.target.error);
      });
    };

    const saveMessage = async (messageULID, message) => {
      const db = await openDB();
      const transaction = db.transaction("messages", "readwrite");
      const store = transaction.objectStore("messages");

      const data = {
        id: messageULID,
        content: message,
        status: "pending",
      };

      store.add(data);
      transaction.oncomplete = () => {
        console.log("Mensaje guardado en IndexedDB");
      };
      transaction.onerror = () => {
        console.error("Error al guardar el mensaje, aÃ±adiendo a la cola de reintento");
        retryQueue.push(data);
        retrySaveMessage();
      };
    };

    const retrySaveMessage = async () => {
      while (retryQueue.length > 0) {
        const db = await openDB();
        const transaction = db.transaction("messages", "readwrite");
        const store = transaction.objectStore("messages");

        const message = retryQueue.shift();

        try {
          store.add(message);
          transaction.oncomplete = () => {
            console.log(`Reintento exitoso: Mensaje ${message.id} guardado`);
          };
        } catch (error) {
          console.error(`Reintento fallido para el mensaje ${message.id}, reinsertando en la cola`);
          retryQueue.push(message);
          break;
        }
      }

      if (retryQueue.length > 0) {
        setTimeout(retrySaveMessage, 5000);
      }
    };

    const messageExists = async (id) => {
      const db = await openDB();
      const transaction = db.transaction("messages", "readonly");
      const store = transaction.objectStore("messages");

      const request = await store.get(id);
      return new Promise((resolve, reject) => {
        const request = store.get(id);

        request.onsuccess = () => {
          resolve(!!request.result);
        };

        request.onerror = () => {
          console.error('Error al buscar el mensaje:', request.error);
          reject(request.error);
        };
      });
    };

    const resendPendingMessages = async (socket) => {
      const db = await openDB();
      const transaction = db.transaction("messages", "readonly");
      const store = transaction.objectStore("messages");
      const index = store.index("status");

      const pendingMessages = [];
      index.openCursor("pending").onsuccess = (event) => {
        const cursor = event.target.result;
        if (cursor) {
          pendingMessages.push(cursor.value);
          cursor.continue();
        } else {
          console.log("Mensajes pendientes encontrados:", pendingMessages);

          pendingMessages.forEach(async (message) => {
            try {
              socket.emit("chat message", message.content, message.id);
            } catch (error) {
              console.error("Error al reenviar mensaje:", message.id);
            }
          });
        }
      };
    };

    const deleteMessage = async (id) => {
      const db = await openDB();
      const transaction = db.transaction("messages", "readwrite");
      const store = transaction.objectStore("messages");

      store.delete(id);
      console.log(`Mensaje ${id} eliminado de IndexedDB`);
    };

    const handleFormSubmit = (socket) => (event) => {
      event.preventDefault();

      const message = input.value.trim();

      if (!message) return;

      const messageULID = ulid();
      const isFirstInChain = lastSenderId !== currentUser.id;
      addMessageToUI(message, messageULID, true, true, currentUser.id);
      lastSenderId = currentUser.id;

      saveMessage(messageULID, message);

      if (socket.connected) {
        socket.emit("chat message", message, messageULID);
      }

      input.value = '';
    };

    const resetFormAndMessages = (socket) => {
      if (formSubmitHandler) {
        form.removeEventListener("submit", formSubmitHandler);
      }
      formSubmitHandler = handleFormSubmit(socket);
      form.addEventListener("submit", formSubmitHandler);

      messages.replaceChildren();
    };

    const addMessageToUI = (message, messageULID, isCurrentUser, isLocal, userId) => {
      let item = document.getElementById(messageULID);

      if (item) return;

      const children = Array.from(messages.children);

      // Encontrar el elemento donde insertar el nuevo mensaje
      const insertBeforeItem = children.find((child) =>
        child.id.localeCompare(messageULID) > 0
      );

      // Determinar el elemento anterior en el DOM
      const previousItem = insertBeforeItem
        ? insertBeforeItem.previousElementSibling
        : children[children.length - 1];

      // Verificar si el mensaje es el primero de la cadena
      const isFirstInChain =
        !previousItem || previousItem.dataset.userId !== userId;

      const itemHTML = `
        <li 
          id="${messageULID}" 
          data-user-id="${userId}" 
          class="${isCurrentUser ? 'local-message' : 'remote-message'} 
            relative p-3 rounded-md 
            ${isCurrentUser ? 'bg-[#d9ffdb]' : 'bg-[#f3f4f6]'} 
            ${isFirstInChain ? 'gap' : ''} 
            ${isCurrentUser ? 'm-[0.2em_0_0.2em_4em]' : 'm-[0.2em_4em_0.2em_0em]'}">
          ${isFirstInChain ?
                `<svg xmlns="http://www.w3.org/2000/svg" class="absolute top-0 ${isCurrentUser ? 'right-0 translate-x-2' : 'left-0 -translate-x-2'}" width="20" height="20" viewBox="0 0 20 20">
              <path d="${isCurrentUser ? 'M0 0 L0 20 L20 0 Z' : 'M20 20 L20 0 L0 0 Z'}" fill="${isCurrentUser ? '#d9ffdb' : '#f3f4f6'}"></path>
            </svg>`
                : ''}
          <p class="content text-gray-800">${message}</p>
        </li>`;

      const template = document.createElement('template');
      template.innerHTML = itemHTML.trim();
      item = template.content.firstChild;

      if (insertBeforeItem) {
        messages.insertBefore(item, insertBeforeItem);
      } else {
        messages.appendChild(item);
      }

      messages.scrollTop = messages.scrollHeight;
    };

    const updateMessageInUI = (newMessage, messageULID) => {
      const item = document.getElementById(messageULID);

      if (!item) return;

      item.querySelector('.content').textContent = newMessage;

      item.classList.remove('local-message');
      item.classList.add('remote-message');
    };

    const handleTokenRefresh = async (socket) => {
      const refreshed = await refreshAccessToken();

      if (refreshed) {
        console.log('--> client -> access token refreshed');
      } else {
        window.location.href = '/access';
      }
    };

    const refreshAccessToken = async () => {
      try {
        const response = await fetch("/refresh", {
          method: "POST",
          credentials: "include",
        });

        if (response.ok) {
          return true;
        } else {
          return false;
        }
      } catch (error) {
        console.error('Trying to renew the token failed');

        return false;
      }
    };

    const connectToSocket = async () => {
      const socket = io({
        auth: {
          token: "USE_COOKIE",
          serverOffset: 0,
        }
      });

      console.log('--> client -> on connectToSocket (NEW)');

      if (socket) {
        await resetFormAndMessages(socket);
      }

      socket.on("chat message", async (message, messageULID, user, messageId) => {
        console.log('--> client -> on chat message : ', message);
        let isInLocalStore;
        const isCurrentUser = user?.id === currentUser.id;

        try {
          isInLocalStore = await messageExists(messageULID);
        } catch (error) {
          isInLocalStore = false;
        }
        const isMessageRendered = isCurrentUser && isInLocalStore;

        if (!isMessageRendered) {
          addMessageToUI(message, messageULID, isCurrentUser, false, user?.id);
        } else {
          await deleteMessage(messageULID);

          updateMessageInUI(message, messageULID);
        }

        socket.auth.serverOffset = messageId;
      });

      socket.on("connect", async () => {
        console.info('--> client on connect');
        await resendPendingMessages(socket);
      });

      socket.on("connect_error", async (error) => {
        if (['Invalid token', 'Token required', 'Token expired'].includes(error.message)) {
          console.info('--> client on connect_error -> Trying to renew the token...', error.message);
          await handleTokenRefresh(socket);
        }
      });

      socket.on("auth_error", async (error) => {
        console.info('--> client auth_error -> Trying to renew the token...', error);
        socket.disconnect();

        await handleTokenRefresh(socket);

        socket.connect();
      });

      socket.on('db_error', async (error) => {
        if (['Message duplicated'].includes(error.message)) {
          socket.disconnect();

          await deleteMessage(error.messageULID);

          socket.connect();
        }
      });
    };

    connectToSocket();
  </script>
</head>

<body class="bg-gray-100 font-sans h-screen">
  <div class="chat max-w-md mx-auto bg-white shadow-lg h-full">
    <!-- Header -->
    <header class="relative bg-[#8b45f7] text-white p-4 flex items-center justify-between">
      <div class="flex items-center space-x-2">
        <div class="rounded-full bg-gray-300 h-8 w-8"></div>
        <h1 class="text-lg font-semibold">
          <%= currentUser.username %>
        </h1>
      </div>
      <button id="menuButton">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v.01M12 12v.01M12 18v.01" />
        </svg>
      </button>
      <div id="menu"
        class="hidden absolute right-6 top-[3em] w-48 bg-white rounded shadow-lg transition-transform duration-300 transform origin-top-right scale-95">
        <a href="/profile" class="block px-4 py-2 text-gray-700 rounded hover:bg-gray-100">Profile</a>
        <form action="/logout" method="POST" class="block">
          <button type="submit" class="w-full text-left px-4 py-2 text-gray-700 rounded hover:bg-gray-100">
            Logout
          </button>
        </form>
      </div>
    </header>

    <!-- Chat Section -->
    <main class="h-[calc(100%-4rem)]">
      <form id="chat-form" class="pb-[4em] flex flex-col space-y-4 overflow-y-auto h-full">
        <ul id="messages" class="list-none m-0 pb-12 p-0 px-4 overflow-y-scroll h-full scroll-smooth"></ul>

        <!-- Input Section -->
        <div class="absolute bottom-0 w-full left-0 bg-gray-200 p-3 flex items-center space-x-2">
          <input id="input" type="text" name="message" autocomplete="off" placeholder="Escribe un mensaje"
            class="flex-1 p-2 rounded-lg border border-gray-300 focus:outline-none focus:ring-2 focus:ring-[#075e54]" />
          <button type="submit" class="bg-[#8b45f7] text-white p-2 rounded-full">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24"
              stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
            </svg>
          </button>
        </div>
      </form>
    </main>
  </div>
</body>

</html>